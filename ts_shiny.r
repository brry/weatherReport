# TLDR: for a smoothed line, use   zoo::rollmean(your_data, window_width, fill=NA)

# How is the moving average influenced by the shape of the weights?
# This app lets you find out interactively :)
# Written by Berry Boessenkool for the course Datascience for Wearables
# May 2025
if(FALSE){ # so you can see my code with syntax highlighting

plot(kernel("daniell", 15)) # uniform window: mean of all datapoints within window
plot(kernel(dnorm(0:35, sd=7))) # weighted average: points at the center influential

# shiny app code generated by claude.ai Sonnet 4 with the following 2 prompts
# prompt 1:
# Please give me the R code for a small shiny app with two sliders and a plot for the following code:
width <- 15 # slider from 3 to 30
sd <- 7 # slider from 3 to 30
smooth <- function(x, ...) # (gaussian) moving average padded with NAs
{
 smoothed <- kernapply(x, kernel(...))
 n <- length(x) - length(smoothed)
 c(rep(NA,n/2), smoothed, rep(NA,n/2))
}
fd <- cumsum(rnorm(500))
plot(fd, type="l")
lines(smooth(fd, "daniell", width), col = "blue", lwd=2) # uniform
lines(smooth(fd, dnorm(0:(sd*5), sd=sd)), col = "orange", lwd=2) # gaussian
}
# this gave way overcomplex ggplot code, so I gave
# prompt 2:
# Can you give me the code with the original base R graph?
# And then I did some manual tweaking :)

# this shows: filter shape is practically irrelevant for the smoothing, 
# with the right window width, the lines overlap almost perfectly.
# Caveat: this may only apply to random walk data. Test with your data yourself.

# unless you cut off the gaussian window weights (and rescale to sum 1), you lose a lot of info at the ends.
# IRL: simply use  zoo::rollmean(your_data, window_width, fill=NA)


library(shiny)

# Define the smooth function
smooth <- function(x, ...) {
  smoothed <- kernapply(x, kernel(...))
  n <- length(x) - length(smoothed)
  c(rep(NA, n/2), smoothed, rep(NA, n/2))
}

# Define UI
ui <- fluidPage(
  titlePanel("Moving Average Filters on Random Walk"),
  
  sidebarLayout(
    sidebarPanel(
      sliderInput("width",
                  "Uniform Filter Width:",
                  min=1,
                  max=50,
                  value=15),
      
      sliderInput("sd",
                  "Gaussian Filter SD:",
                  min=1,
                  max=50,
                  value=7),
      
      br(),
      actionButton("regenerate", "Generate New Random Walk", 
                   class="btn-primary")
    ),
    
    mainPanel(
      plotOutput("plot", height="500px")
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  
  # Reactive value to store the random walk data
  rw_data <- reactiveVal(cumsum(rnorm(500)))
  
  # Regenerate data when button is clicked
  observeEvent(input$regenerate, {
    rw_data(cumsum(rnorm(500)))
  })
  
  output$plot <- renderPlot({
    fd <- rw_data()
    plot(fd, type="l", main="Random Walk with Moving Average Filters",
         xlab="Time", ylab="Value", las=1)
    lines(smooth(fd, "daniell", input$width), col="blue", lwd=6)
    lines(smooth(fd, dnorm(0:(input$sd*5), sd=input$sd)), col="orange", lwd=6)
    # lines(zoo::rollmean(fd, input$width*2, fill=NA), col="forestgreen", lwd=6) + the same as daniell kernel

    legend("topright", legend=c("Original", "Uniform", "Gaussian"),
           col=c("black", "blue", "orange"), lwd=c(1, 3,3))
  })
}

# Run the application
shinyApp(ui=ui, server=server)
